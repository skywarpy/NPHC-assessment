package org.nphc.services;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.nphc.entities.Employee;
import org.nphc.exceptions.DateFormatException;
import org.nphc.exceptions.DuplicateIDFoundException;
import org.nphc.exceptions.EmployeeNotFoundException;
import org.nphc.exceptions.SalaryFormatException;
import org.nphc.repositories.EmployeeRepo;
import org.nphc.utilities.CSVReader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

/**
 * This is a Service bean used to interact with an instance of EmployeeRepo. 
 * It contains methods to save Employees to EmployeeRepo from a MultipartFile, save Employee to EmployeeRepo,
 * return all Employees from EmployeeRepo, return Employee based on Employee id, delete Employee based on Employee id.
 * It supports pagination for the method to return all Employees who meet the parameters of minSalary and maxSalary.
 */

@Service
public class EmployeeService {
	@Autowired
	EmployeeRepo employeeRepo;
	
	/**
	 * This is a method to save Employees to a repository EmployeeRepo from a MultipartFile file. Returns a boolean value updated=true if
	 * there were changes made to the repository, updated=false if no changes were made.
	 * 
	 * First checks for duplicate IDs within the list of Employees pulled from the file, by creating a HashSet to store only unique IDs.
	 * It then compares the size of the HashSet against a list of the Employee IDs. If the HashSet is smaller, duplicate IDs are present.
	 * Throws a DuplicateIDFoundException if duplicate IDs are found.
	 * 
	 * If the repository is empty, it will save all Employees from the file to the repository and set boolean updated = true. 
	 * 
	 * Iterates across the list of employees generated by the MultipartFile and checks if it exists in the repository.
	 * If it exists, compares values of Name, Login, Salary and Date between the two. If there are changes, overwrite the old Employee
	 * in the repository, and then set boolean updated = true.
	 * 
	 * If the employee does not exist in the repository, save the new Employee to the repository and set boolean updated = true.
	 * 
	 * If no changes are found, return boolean updated = false.
	 * 
	 * Throws DateFormatException and SalaryFormatException if there are issues with parsing startDate and salary through utility class CSVReader.
	 * 
	 * @param file
	 * @return
	 * @throws DateFormatException
	 * @throws SalaryFormatException
	 * @throws DuplicateIDFoundException
	 */
	public boolean save(MultipartFile file) throws DateFormatException, SalaryFormatException, DuplicateIDFoundException  {
		boolean updated=false;
		try {
			List<Employee> employees = CSVReader.csvToEmployees(file.getInputStream());
			/*checking for duplicate IDs - compares count of unique employee IDs against total number of employee IDs in the CSV*/
			List<String> empId= new ArrayList<String>();
			employees.forEach((Employee e) -> empId.add(e.getId()));
			Set<String> empIdSet = new HashSet<String>(empId);
			System.out.println(empId.size());
			System.out.println(empIdSet.size());
			if(empIdSet.size() < empId.size()){
			    /* There are duplicates */
				throw new DuplicateIDFoundException("Duplicate IDs in CSV");
			}
			
			List<Employee> currentDatabaseEmployees = getAllEmployees();
			List<String> currentDatabaseEmpId= new ArrayList<String>();
			currentDatabaseEmployees.forEach((Employee e) -> currentDatabaseEmpId.add(e.getId()));
			
			if (currentDatabaseEmployees.isEmpty()) {
				employeeRepo.saveAll(employees);
				updated=true;
				return updated;
			} else {
				for (Employee emp : employees) {
					if (employeeRepo.existsById(emp.getId())) {
						if(!emp.equals(employeeRepo.getReferenceById(emp.getId()))) {
							employeeRepo.save(emp);
							updated=true;
						}
					} else {
						employeeRepo.save(emp);
						updated=true;
					}
					
				}
			}
			return updated;
		} catch (IOException e) {
			throw new RuntimeException("Failed to store CSV data" + e.getMessage());
		} 
	}
	
	public Employee addEmployee(Employee employee) {
		employeeRepo.save(employee);
		return employee;
	}
	
	public List<Employee> getAllEmployees() {
		return employeeRepo.findAll();
	}
	
	/**
	 * Returns a list of Employees based on the parameters of a lower bound lowSalary, an upper bound higherSalary from the repository.
	 * Supports pagination through the use of offset and limit.
	 * @param lowerSalary
	 * @param higherSalary
	 * @param offset
	 * @param limit
	 * @return
	 */
	
	
	public List<Employee> getEmployeesWithLimit(BigDecimal lowerSalary, BigDecimal higherSalary, int offset, int limit) {
		return employeeRepo.findAllBySalaryRangeWithOffsetAndLimit(lowerSalary, higherSalary, PageRequest.of(offset, limit));
	}
	/**
	 * Returns an Employee from repository by id. If the Employee cannot be found, it will throw EmployeeNotFoundException.
	 * @param id
	 * @return
	 */
	public Employee getEmployee(String id) {
		return employeeRepo.findById(id).orElseThrow(()-> new EmployeeNotFoundException("No such employee"));
	}
	
	/**
	 * Method to delete Employee from repository by id. First checks to see if the Employee exists, if not, throws EmployeeNotFoundException.
	 * Else, it will delete the Employee.
	 * @param id
	 */
	
	
	public void deleteEmployee(String id) {
		Employee emp = employeeRepo.findById(id).orElseThrow(()-> new EmployeeNotFoundException("No such employee"));
		employeeRepo.delete(emp);
	}
}
